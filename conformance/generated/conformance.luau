--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("./proto")

type _FailureSetImpl = {
	__index: _FailureSetImpl,
	new: () -> FailureSet,
	encode: (self: FailureSet) -> string,
	decode: (input: buffer) -> FailureSet,
	jsonEncode: (self: FailureSet) -> any,
	jsonDecode: (input: { [string]: any }) -> FailureSet,
}

type _FailureSetFields = {
	failure: { string },
}

export type FailureSet = typeof(setmetatable({} :: _FailureSetFields, {} :: _FailureSetImpl))
type _ConformanceRequestImpl = {
	__index: _ConformanceRequestImpl,
	new: () -> ConformanceRequest,
	encode: (self: ConformanceRequest) -> string,
	decode: (input: buffer) -> ConformanceRequest,
	jsonEncode: (self: ConformanceRequest) -> any,
	jsonDecode: (input: { [string]: any }) -> ConformanceRequest,
}

type _ConformanceRequestFields = {
	payload: (
		{ type: "protobuf_payload", value: buffer }
		| { type: "json_payload", value: string }
		| { type: "jspb_payload", value: string }
		| { type: "text_payload", value: string }
	)?,
	requested_output_format: WireFormat,
	message_type: string,
	test_category: TestCategory,
	jspb_encoding_options: JspbEncodingConfig?,
	print_unknown_fields: boolean,
}

export type ConformanceRequest = typeof(setmetatable({} :: _ConformanceRequestFields, {} :: _ConformanceRequestImpl))
type _ConformanceResponseImpl = {
	__index: _ConformanceResponseImpl,
	new: () -> ConformanceResponse,
	encode: (self: ConformanceResponse) -> string,
	decode: (input: buffer) -> ConformanceResponse,
	jsonEncode: (self: ConformanceResponse) -> any,
	jsonDecode: (input: { [string]: any }) -> ConformanceResponse,
}

type _ConformanceResponseFields = {
	result: (
		{ type: "parse_error", value: string }
		| { type: "serialize_error", value: string }
		| { type: "timeout_error", value: string }
		| { type: "runtime_error", value: string }
		| { type: "protobuf_payload", value: buffer }
		| { type: "json_payload", value: string }
		| { type: "skipped", value: string }
		| { type: "jspb_payload", value: string }
		| { type: "text_payload", value: string }
	)?,
}

export type ConformanceResponse = typeof(setmetatable({} :: _ConformanceResponseFields, {} :: _ConformanceResponseImpl))
type _JspbEncodingConfigImpl = {
	__index: _JspbEncodingConfigImpl,
	new: () -> JspbEncodingConfig,
	encode: (self: JspbEncodingConfig) -> string,
	decode: (input: buffer) -> JspbEncodingConfig,
	jsonEncode: (self: JspbEncodingConfig) -> any,
	jsonDecode: (input: { [string]: any }) -> JspbEncodingConfig,
}

type _JspbEncodingConfigFields = {
	use_jspb_array_any_format: boolean,
}

export type JspbEncodingConfig = typeof(setmetatable({} :: _JspbEncodingConfigFields, {} :: _JspbEncodingConfigImpl))
local WireFormat: proto.Enum<WireFormat>
export type WireFormat = "UNSPECIFIED" | "PROTOBUF" | "JSON" | "JSPB" | "TEXT_FORMAT" | number -- Unknown

local TestCategory: proto.Enum<TestCategory>
export type TestCategory =
	"UNSPECIFIED_TEST"
	| "BINARY_TEST"
	| "JSON_TEST"
	| "JSON_IGNORE_UNKNOWN_PARSING_TEST"
	| "JSPB_TEST"
	| "TEXT_FORMAT_TEST"
	| number -- Unknown

local FailureSet: proto.Message<_FailureSetImpl> = {} :: _FailureSetImpl
FailureSet.__index = FailureSet

function FailureSet.new(data: _FailureSetFields?): FailureSet
	return setmetatable({
		failure = data and data["failure"] or {},
	}, FailureSet)
end

function FailureSet.encode(self: FailureSet): buffer
	local output = buffer.create(0)
	local cursor = 0

	if #self.failure > 0 then
		for _, value: string in self.failure do
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, value)
		end
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function FailureSet.decode(input: buffer): FailureSet
	local self = FailureSet.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.failure, buffer.tostring(value))
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function FailureSet.jsonEncode(self: FailureSet): any
	local output: {
		failure: { string }?,
	} = {}

	if #self.failure > 0 then
		local newOutput: { string } = {}
		for _, value: string in self.failure do
			table.insert(newOutput, value)
		end
		output.failure = newOutput
	end

	return output
end

function FailureSet.jsonDecode(input: { [string]: any }): FailureSet
	local self = FailureSet.new()

	if input.failure ~= nil then
		local newOutput: { string } = {}
		for _, value: string in input.failure do
			table.insert(newOutput, value)
		end

		self.failure = newOutput
	end

	return self
end

local ConformanceRequest: proto.Message<_ConformanceRequestImpl> = {} :: _ConformanceRequestImpl
ConformanceRequest.__index = ConformanceRequest

function ConformanceRequest.new(data: _ConformanceRequestFields?): ConformanceRequest
	return setmetatable({
		payload = data and data["payload"] or nil,
		requested_output_format = data and data["requested_output_format"]
			or assert(WireFormat.fromNumber(0), "Enum has no 0 default"),
		message_type = data and data["message_type"] or "",
		test_category = data and data["test_category"] or assert(TestCategory.fromNumber(0), "Enum has no 0 default"),
		jspb_encoding_options = data and data["jspb_encoding_options"] or nil,
		print_unknown_fields = data and data["print_unknown_fields"] or false,
	}, ConformanceRequest)
end

function ConformanceRequest.encode(self: ConformanceRequest): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.payload ~= nil then
		if self.payload.type == "protobuf_payload" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, self.payload.value, buffer.len(self.payload.value))
		elseif self.payload.type == "json_payload" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.payload.value)
		elseif self.payload.type == "jspb_payload" then
			output, cursor = proto.writeTag(output, cursor, 7, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.payload.value)
		elseif self.payload.type == "text_payload" then
			output, cursor = proto.writeTag(output, cursor, 8, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.payload.value)
		end
	end

	if self.requested_output_format ~= 0 or self.requested_output_format ~= WireFormat.fromNumber(0) then
		output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, WireFormat.toNumber(self.requested_output_format))
	end

	if self.message_type ~= "" then
		output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.message_type)
	end

	if self.test_category ~= 0 or self.test_category ~= TestCategory.fromNumber(0) then
		output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, TestCategory.toNumber(self.test_category))
	end

	if self.jspb_encoding_options ~= nil then
		local encoded = JspbEncodingConfig.encode(self.jspb_encoding_options)
		output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
	end

	if self.print_unknown_fields then
		output, cursor = proto.writeTag(output, cursor, 9, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, if self.print_unknown_fields then 1 else 0)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function ConformanceRequest.decode(input: buffer): ConformanceRequest
	local self = ConformanceRequest.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 3 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.requested_output_format = WireFormat.fromNumber(value) or value
			elseif field == 5 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.test_category = TestCategory.fromNumber(value) or value
			elseif field == 9 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.print_unknown_fields = value ~= 0
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.payload = { type = "protobuf_payload", value = value }
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.payload = { type = "json_payload", value = buffer.tostring(value) }
			elseif field == 4 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.message_type = buffer.tostring(value)
			elseif field == 6 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.jspb_encoding_options = JspbEncodingConfig.decode(value)
			elseif field == 7 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.payload = { type = "jspb_payload", value = buffer.tostring(value) }
			elseif field == 8 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.payload = { type = "text_payload", value = buffer.tostring(value) }
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function ConformanceRequest.jsonEncode(self: ConformanceRequest): any
	local output: {
		protobufPayload: buffer?,
		jsonPayload: string?,
		jspbPayload: string?,
		textPayload: string?,
		requestedOutputFormat: WireFormat?,
		messageType: string?,
		testCategory: TestCategory?,
		jspbEncodingOptions: JspbEncodingConfig?,
		printUnknownFields: boolean?,
	} =
		{}

	if self.payload ~= nil then
		if self.payload.type == "protobuf_payload" then
			output.protobufPayload = proto.json.serializeBuffer(self.payload.value)
		elseif self.payload.type == "json_payload" then
			output.jsonPayload = self.payload.value
		elseif self.payload.type == "jspb_payload" then
			output.jspbPayload = self.payload.value
		elseif self.payload.type == "text_payload" then
			output.textPayload = self.payload.value
		end
	end

	if self.requested_output_format ~= 0 or self.requested_output_format ~= WireFormat.fromNumber(0) then
		output.requestedOutputFormat = if typeof(self.requested_output_format) == "number"
			then self.requested_output_format
			else WireFormat.toNumber(self.requested_output_format)
	end

	if self.message_type ~= "" then
		output.messageType = self.message_type
	end

	if self.test_category ~= 0 or self.test_category ~= TestCategory.fromNumber(0) then
		output.testCategory = if typeof(self.test_category) == "number"
			then self.test_category
			else TestCategory.toNumber(self.test_category)
	end

	if self.jspb_encoding_options ~= nil then
		output.jspbEncodingOptions = JspbEncodingConfig.jsonEncode(self.jspb_encoding_options)
	end

	if self.print_unknown_fields then
		output.printUnknownFields = self.print_unknown_fields
	end

	return output
end

function ConformanceRequest.jsonDecode(input: { [string]: any }): ConformanceRequest
	local self = ConformanceRequest.new()

	if input.protobuf_payload ~= nil then
		self.payload = { type = "protobuf_payload", value = proto.json.deserializeBuffer(input.protobuf_payload) }
	end

	if input.protobufPayload ~= nil then
		self.payload = { type = "protobuf_payload", value = proto.json.deserializeBuffer(input.protobufPayload) }
	end

	if input.json_payload ~= nil then
		self.payload = { type = "json_payload", value = input.json_payload }
	end

	if input.jsonPayload ~= nil then
		self.payload = { type = "json_payload", value = input.jsonPayload }
	end

	if input.jspb_payload ~= nil then
		self.payload = { type = "jspb_payload", value = input.jspb_payload }
	end

	if input.jspbPayload ~= nil then
		self.payload = { type = "jspb_payload", value = input.jspbPayload }
	end

	if input.text_payload ~= nil then
		self.payload = { type = "text_payload", value = input.text_payload }
	end

	if input.textPayload ~= nil then
		self.payload = { type = "text_payload", value = input.textPayload }
	end

	if input.requested_output_format ~= nil then
		self.requested_output_format = if typeof(input.requested_output_format) == "number"
			then (WireFormat.fromNumber(input.requested_output_format) or input.requested_output_format)
			else (WireFormat.fromName(input.requested_output_format) or input.requested_output_format)
	end

	if input.requestedOutputFormat ~= nil then
		self.requested_output_format = if typeof(input.requestedOutputFormat) == "number"
			then (WireFormat.fromNumber(input.requestedOutputFormat) or input.requestedOutputFormat)
			else (WireFormat.fromName(input.requestedOutputFormat) or input.requestedOutputFormat)
	end

	if input.message_type ~= nil then
		self.message_type = input.message_type
	end

	if input.messageType ~= nil then
		self.message_type = input.messageType
	end

	if input.test_category ~= nil then
		self.test_category = if typeof(input.test_category) == "number"
			then (TestCategory.fromNumber(input.test_category) or input.test_category)
			else (TestCategory.fromName(input.test_category) or input.test_category)
	end

	if input.testCategory ~= nil then
		self.test_category = if typeof(input.testCategory) == "number"
			then (TestCategory.fromNumber(input.testCategory) or input.testCategory)
			else (TestCategory.fromName(input.testCategory) or input.testCategory)
	end

	if input.jspb_encoding_options ~= nil then
		self.jspb_encoding_options = JspbEncodingConfig.jsonDecode(input.jspb_encoding_options)
	end

	if input.jspbEncodingOptions ~= nil then
		self.jspb_encoding_options = JspbEncodingConfig.jsonDecode(input.jspbEncodingOptions)
	end

	if input.print_unknown_fields ~= nil then
		self.print_unknown_fields = input.print_unknown_fields
	end

	if input.printUnknownFields ~= nil then
		self.print_unknown_fields = input.printUnknownFields
	end

	return self
end

local ConformanceResponse: proto.Message<_ConformanceResponseImpl> = {} :: _ConformanceResponseImpl
ConformanceResponse.__index = ConformanceResponse

function ConformanceResponse.new(data: _ConformanceResponseFields?): ConformanceResponse
	return setmetatable({
		result = data and data["result"] or nil,
	}, ConformanceResponse)
end

function ConformanceResponse.encode(self: ConformanceResponse): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.result ~= nil then
		if self.result.type == "parse_error" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.result.value)
		elseif self.result.type == "serialize_error" then
			output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.result.value)
		elseif self.result.type == "timeout_error" then
			output, cursor = proto.writeTag(output, cursor, 9, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.result.value)
		elseif self.result.type == "runtime_error" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.result.value)
		elseif self.result.type == "protobuf_payload" then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, self.result.value, buffer.len(self.result.value))
		elseif self.result.type == "json_payload" then
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.result.value)
		elseif self.result.type == "skipped" then
			output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.result.value)
		elseif self.result.type == "jspb_payload" then
			output, cursor = proto.writeTag(output, cursor, 7, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.result.value)
		elseif self.result.type == "text_payload" then
			output, cursor = proto.writeTag(output, cursor, 8, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.result.value)
		end
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function ConformanceResponse.decode(input: buffer): ConformanceResponse
	local self = ConformanceResponse.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "parse_error", value = buffer.tostring(value) }
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "runtime_error", value = buffer.tostring(value) }
			elseif field == 3 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "protobuf_payload", value = value }
			elseif field == 4 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "json_payload", value = buffer.tostring(value) }
			elseif field == 5 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "skipped", value = buffer.tostring(value) }
			elseif field == 6 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "serialize_error", value = buffer.tostring(value) }
			elseif field == 7 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "jspb_payload", value = buffer.tostring(value) }
			elseif field == 8 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "text_payload", value = buffer.tostring(value) }
			elseif field == 9 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.result = { type = "timeout_error", value = buffer.tostring(value) }
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function ConformanceResponse.jsonEncode(self: ConformanceResponse): any
	local output: {
		parseError: string?,
		serializeError: string?,
		timeoutError: string?,
		runtimeError: string?,
		protobufPayload: buffer?,
		jsonPayload: string?,
		skipped: string?,
		jspbPayload: string?,
		textPayload: string?,
	} =
		{}

	if self.result ~= nil then
		if self.result.type == "parse_error" then
			output.parseError = self.result.value
		elseif self.result.type == "serialize_error" then
			output.serializeError = self.result.value
		elseif self.result.type == "timeout_error" then
			output.timeoutError = self.result.value
		elseif self.result.type == "runtime_error" then
			output.runtimeError = self.result.value
		elseif self.result.type == "protobuf_payload" then
			output.protobufPayload = proto.json.serializeBuffer(self.result.value)
		elseif self.result.type == "json_payload" then
			output.jsonPayload = self.result.value
		elseif self.result.type == "skipped" then
			output.skipped = self.result.value
		elseif self.result.type == "jspb_payload" then
			output.jspbPayload = self.result.value
		elseif self.result.type == "text_payload" then
			output.textPayload = self.result.value
		end
	end

	return output
end

function ConformanceResponse.jsonDecode(input: { [string]: any }): ConformanceResponse
	local self = ConformanceResponse.new()

	if input.parse_error ~= nil then
		self.result = { type = "parse_error", value = input.parse_error }
	end

	if input.parseError ~= nil then
		self.result = { type = "parse_error", value = input.parseError }
	end

	if input.serialize_error ~= nil then
		self.result = { type = "serialize_error", value = input.serialize_error }
	end

	if input.serializeError ~= nil then
		self.result = { type = "serialize_error", value = input.serializeError }
	end

	if input.timeout_error ~= nil then
		self.result = { type = "timeout_error", value = input.timeout_error }
	end

	if input.timeoutError ~= nil then
		self.result = { type = "timeout_error", value = input.timeoutError }
	end

	if input.runtime_error ~= nil then
		self.result = { type = "runtime_error", value = input.runtime_error }
	end

	if input.runtimeError ~= nil then
		self.result = { type = "runtime_error", value = input.runtimeError }
	end

	if input.protobuf_payload ~= nil then
		self.result = { type = "protobuf_payload", value = proto.json.deserializeBuffer(input.protobuf_payload) }
	end

	if input.protobufPayload ~= nil then
		self.result = { type = "protobuf_payload", value = proto.json.deserializeBuffer(input.protobufPayload) }
	end

	if input.json_payload ~= nil then
		self.result = { type = "json_payload", value = input.json_payload }
	end

	if input.jsonPayload ~= nil then
		self.result = { type = "json_payload", value = input.jsonPayload }
	end

	if input.skipped ~= nil then
		self.result = { type = "skipped", value = input.skipped }
	end

	if input.jspb_payload ~= nil then
		self.result = { type = "jspb_payload", value = input.jspb_payload }
	end

	if input.jspbPayload ~= nil then
		self.result = { type = "jspb_payload", value = input.jspbPayload }
	end

	if input.text_payload ~= nil then
		self.result = { type = "text_payload", value = input.text_payload }
	end

	if input.textPayload ~= nil then
		self.result = { type = "text_payload", value = input.textPayload }
	end

	return self
end

local JspbEncodingConfig: proto.Message<_JspbEncodingConfigImpl> = {} :: _JspbEncodingConfigImpl
JspbEncodingConfig.__index = JspbEncodingConfig

function JspbEncodingConfig.new(data: _JspbEncodingConfigFields?): JspbEncodingConfig
	return setmetatable({
		use_jspb_array_any_format = data and data["use_jspb_array_any_format"] or false,
	}, JspbEncodingConfig)
end

function JspbEncodingConfig.encode(self: JspbEncodingConfig): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.use_jspb_array_any_format then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, if self.use_jspb_array_any_format then 1 else 0)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function JspbEncodingConfig.decode(input: buffer): JspbEncodingConfig
	local self = JspbEncodingConfig.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.use_jspb_array_any_format = value ~= 0
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function JspbEncodingConfig.jsonEncode(self: JspbEncodingConfig): any
	local output: {
		useJspbArrayAnyFormat: boolean?,
	} = {}

	if self.use_jspb_array_any_format then
		output.useJspbArrayAnyFormat = self.use_jspb_array_any_format
	end

	return output
end

function JspbEncodingConfig.jsonDecode(input: { [string]: any }): JspbEncodingConfig
	local self = JspbEncodingConfig.new()

	if input.use_jspb_array_any_format ~= nil then
		self.use_jspb_array_any_format = input.use_jspb_array_any_format
	end

	if input.useJspbArrayAnyFormat ~= nil then
		self.use_jspb_array_any_format = input.useJspbArrayAnyFormat
	end

	return self
end

WireFormat = {
	fromNumber = function(value: number): WireFormat?
		if value == 0 then
			return "UNSPECIFIED"
		elseif value == 1 then
			return "PROTOBUF"
		elseif value == 2 then
			return "JSON"
		elseif value == 3 then
			return "JSPB"
		elseif value == 4 then
			return "TEXT_FORMAT"
		else
			return nil
		end
	end,

	toNumber = function(self: WireFormat): number
		if self == "UNSPECIFIED" then
			return 0
		elseif self == "PROTOBUF" then
			return 1
		elseif self == "JSON" then
			return 2
		elseif self == "JSPB" then
			return 3
		elseif self == "TEXT_FORMAT" then
			return 4
		else
			return self
		end
	end,

	fromName = function(name: string): WireFormat?
		if name == "UNSPECIFIED" then
			return "UNSPECIFIED"
		elseif name == "PROTOBUF" then
			return "PROTOBUF"
		elseif name == "JSON" then
			return "JSON"
		elseif name == "JSPB" then
			return "JSPB"
		elseif name == "TEXT_FORMAT" then
			return "TEXT_FORMAT"
		else
			return nil
		end
	end,
}

TestCategory = {
	fromNumber = function(value: number): TestCategory?
		if value == 0 then
			return "UNSPECIFIED_TEST"
		elseif value == 1 then
			return "BINARY_TEST"
		elseif value == 2 then
			return "JSON_TEST"
		elseif value == 3 then
			return "JSON_IGNORE_UNKNOWN_PARSING_TEST"
		elseif value == 4 then
			return "JSPB_TEST"
		elseif value == 5 then
			return "TEXT_FORMAT_TEST"
		else
			return nil
		end
	end,

	toNumber = function(self: TestCategory): number
		if self == "UNSPECIFIED_TEST" then
			return 0
		elseif self == "BINARY_TEST" then
			return 1
		elseif self == "JSON_TEST" then
			return 2
		elseif self == "JSON_IGNORE_UNKNOWN_PARSING_TEST" then
			return 3
		elseif self == "JSPB_TEST" then
			return 4
		elseif self == "TEXT_FORMAT_TEST" then
			return 5
		else
			return self
		end
	end,

	fromName = function(name: string): TestCategory?
		if name == "UNSPECIFIED_TEST" then
			return "UNSPECIFIED_TEST"
		elseif name == "BINARY_TEST" then
			return "BINARY_TEST"
		elseif name == "JSON_TEST" then
			return "JSON_TEST"
		elseif name == "JSON_IGNORE_UNKNOWN_PARSING_TEST" then
			return "JSON_IGNORE_UNKNOWN_PARSING_TEST"
		elseif name == "JSPB_TEST" then
			return "JSPB_TEST"
		elseif name == "TEXT_FORMAT_TEST" then
			return "TEXT_FORMAT_TEST"
		else
			return nil
		end
	end,
}

return {
	FailureSet = FailureSet,
	ConformanceRequest = ConformanceRequest,
	ConformanceResponse = ConformanceResponse,
	JspbEncodingConfig = JspbEncodingConfig,
	WireFormat = WireFormat,
	TestCategory = TestCategory,
}
