--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")
local typeRegistry = require("../../proto/typeRegistry")

type _DurationImpl = {
	__index: _DurationImpl,
	new: (fields: _DurationPartialFields?) -> Duration,
	encode: (self: Duration) -> buffer,
	decode: (input: buffer) -> Duration,
	jsonEncode: (self: Duration) -> string,
	jsonDecode: (input: string) -> Duration,
	descriptor: proto.Descriptor,
}

type _DurationFields = {
	seconds: number,
	nanos: number,
}

type _DurationPartialFields = {
	seconds: number?,
	nanos: number?,
}

export type Duration = typeof(setmetatable({} :: _DurationFields, {} :: _DurationImpl))
local Duration: proto.Message<Duration, _DurationPartialFields> & proto.CustomJson<Duration, string>

local _DurationImpl = {}
_DurationImpl.__index = _DurationImpl

function _DurationImpl.new(data: _DurationPartialFields?): Duration
	return setmetatable({
		seconds = if data == nil or data.seconds == nil then 0 else data.seconds,
		nanos = if data == nil or data.nanos == nil then 0 else data.nanos,
	}, _DurationImpl)
end

function _DurationImpl.encode(self: Duration): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.seconds ~= nil and self.seconds ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.seconds)
	end

	if self.nanos ~= nil and self.nanos ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.nanos)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _DurationImpl.decode(input: buffer): Duration
	local self = _DurationImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.seconds = value
			elseif field == 2 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.nanos = proto.limitInt32(value)
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

-- Converts a number of nanos to a string representation.
-- Sign and trailing zeroes are dropped.
-- 500000000 -> ".5s"
-- 500000001 -> ".500000001s"
-- 0 -> ".0s"
-- 1 -> ".000000001s"
-- -1 -> "-.000000001s"
local function serializeFractionalNanos(nanos: number): string
	nanos = nanos * math.sign(nanos)

	local nanosText = tostring(nanos)
	local nanosTextLength = #nanosText

	local leadingZeroes = 9 - nanosTextLength
	local leadingZeroesText = string.rep("0", leadingZeroes)

	-- remove trailing zeroes
	while nanosText:sub(-1) == "0" do
		nanosText = nanosText:sub(1, -2)
	end

	return `.{leadingZeroesText}{nanosText}s`
end

local function deserializeFractionalNanos(nanosText: string): number
	local nanos = assert(tonumber(nanosText), "Invalid nanos string received, couldn't turn into a number")
	for digit = #nanosText + 1, 9 do
		nanos *= 10
	end

	return nanos
end

function _DurationImpl.jsonEncode(duration: Duration): string
	assert(
		duration.seconds == nil or (duration.seconds >= -315576000000 and duration.seconds <= 315576000000),
		"Seconds out of range"
	)
	assert(
		duration.nanos == nil or (duration.nanos >= -999999999 and duration.nanos <= 999999999),
		"Nanoseconds out of range"
	)

	-- TODO: For durations of one second or more, a non-zero value for the nanos field must be of the same sign as the seconds field.
	if duration.nanos == nil or duration.nanos == 0 or duration.nanos % 1e9 == 0 then
		return `{duration.seconds}s`
	end

	local nanoSign = if duration.seconds == 0 and math.sign(duration.nanos) == -1 then "-" else ""
	return string.format("%s%d%s", nanoSign, duration.seconds or 0, serializeFractionalNanos(duration.nanos))
end

function _DurationImpl.jsonDecode(anyValue: any): Duration
	local maxSeconds = 315576000000
	local minSeconds = -315576000000
	local durationString: string = anyValue
	local simpleSecondsText = string.match(durationString, "^([%-0-9]+)s$")
	local seconds = 0
	local nanos = 0
	if simpleSecondsText ~= nil then
		seconds = assert(
			tonumber(simpleSecondsText),
			"Invalid duration string received--was formatted as just having seconds, but wasn't a properly formatted int"
		)
	else
		local secondsText, nanosText = string.match(durationString, "^([%-0-9]+)%.([0-9]+)s$")
		assert(secondsText ~= nil, "Invalid duration string received--seconds provided are invalid")
		assert(nanosText ~= nil, "Invalid duration string received--nanos provided are invalid")

		seconds = assert(tonumber(secondsText), "Invalid duration string received--seconds provided are invalid")
		nanos = deserializeFractionalNanos(nanosText) * (secondsText:sub(1, 1) == "-" and -1 or 1)
	end

	if seconds > maxSeconds then
		error(`Duration seconds cannot exceed {maxSeconds}`)
	elseif seconds < minSeconds then
		error(`Duration seconds cannot be less than {minSeconds}`)
	end

	return Duration.new({
		seconds = seconds,
		nanos = nanos,
	})
end

_DurationImpl.descriptor = {
	name = "Duration",
	fullName = "google.protobuf.Duration",
}

Duration = _DurationImpl

typeRegistry.default:register(Duration)

return {
	Duration = Duration,
}
