--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")

type _FieldMaskImpl = {
	__index: _FieldMaskImpl,
	new: () -> FieldMask,
	encode: (self: FieldMask) -> buffer,
	decode: (input: buffer) -> FieldMask,
	jsonEncode: (self: FieldMask) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FieldMask,
}

type _FieldMaskFields = {
	paths: { string },
}

export type FieldMask = typeof(setmetatable({} :: _FieldMaskFields, {} :: _FieldMaskImpl))

local FieldMask: proto.Message<_FieldMaskImpl> = {} :: _FieldMaskImpl
FieldMask.__index = FieldMask

function FieldMask.new(data: _FieldMaskFields?): FieldMask
	return setmetatable({
		paths = data and data["paths"] or {},
	}, FieldMask)
end

function FieldMask.encode(self: FieldMask): buffer
	local output = buffer.create(0)
	local cursor = 0

	if #self.paths > 0 then
		for _, value: string in self.paths do
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, value)
		end
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function FieldMask.decode(input: buffer): FieldMask
	local self = FieldMask.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.paths, buffer.tostring(value))
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function FieldMask.jsonEncode(self: FieldMask): any
	local output: {
		paths: { string }?,
	} = {}

	if #self.paths > 0 then
		local newOutput: { string } = {}
		for _, value: string in self.paths do
			table.insert(newOutput, value)
		end
		output.paths = newOutput
	end

	return output
end

function FieldMask.jsonDecode(input: { [string]: any }): FieldMask
	local self = FieldMask.new()

	if input.paths ~= nil then
		local newOutput: { string } = {}
		for _, value: string in input.paths do
			table.insert(newOutput, value)
		end

		self.paths = newOutput
	end

	return self
end

return {
	FieldMask = FieldMask,
}
