--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")
local wktJson = require("../../proto/wktJson")

local DoubleValue: proto.Message<DoubleValue>
export type DoubleValue = {
	value: number,
}

local FloatValue: proto.Message<FloatValue>
export type FloatValue = {
	value: number,
}

local Int64Value: proto.Message<Int64Value>
export type Int64Value = {
	value: number,
}

local UInt64Value: proto.Message<UInt64Value>
export type UInt64Value = {
	value: number,
}

local Int32Value: proto.Message<Int32Value>
export type Int32Value = {
	value: number,
}

local UInt32Value: proto.Message<UInt32Value>
export type UInt32Value = {
	value: number,
}

local BoolValue: proto.Message<BoolValue>
export type BoolValue = {
	value: boolean,
}

local StringValue: proto.Message<StringValue>
export type StringValue = {
	value: string,
}

local BytesValue: proto.Message<BytesValue>
export type BytesValue = {
	value: buffer,
}

DoubleValue = {
	new = function()
		return {
			value = 0,
		}
	end,

	encode = function(self: DoubleValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i64)
			output, cursor = proto.writeDouble(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): DoubleValue
		local self = DoubleValue.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				if field == 1 then
					local value
					value, cursor = proto.readDouble(input, cursor)
					self.value = value
				end
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: DoubleValue): any
		return wktJson.DoubleValue.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): DoubleValue
		return wktJson.DoubleValue.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

FloatValue = {
	new = function()
		return {
			value = 0,
		}
	end,

	encode = function(self: FloatValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i32)
			output, cursor = proto.writeFloat(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): FloatValue
		local self = FloatValue.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields
			elseif wireType == proto.wireTypes.i32 then
				if field == 1 then
					local value
					value, cursor = proto.readFloat(input, cursor)
					self.value = value
				end
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: FloatValue): any
		return wktJson.FloatValue.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): FloatValue
		return wktJson.FloatValue.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

Int64Value = {
	new = function()
		return {
			value = 0,
		}
	end,

	encode = function(self: Int64Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): Int64Value
		local self = Int64Value.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.value = value
				end
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: Int64Value): any
		return wktJson.Int64Value.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): Int64Value
		return wktJson.Int64Value.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

UInt64Value = {
	new = function()
		return {
			value = 0,
		}
	end,

	encode = function(self: UInt64Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): UInt64Value
		local self = UInt64Value.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.value = value
				end
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: UInt64Value): any
		return wktJson.UInt64Value.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): UInt64Value
		return wktJson.UInt64Value.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

Int32Value = {
	new = function()
		return {
			value = 0,
		}
	end,

	encode = function(self: Int32Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): Int32Value
		local self = Int32Value.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.value = proto.limitInt32(value)
				end
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: Int32Value): any
		return wktJson.Int32Value.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): Int32Value
		return wktJson.Int32Value.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

UInt32Value = {
	new = function()
		return {
			value = 0,
		}
	end,

	encode = function(self: UInt32Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): UInt32Value
		local self = UInt32Value.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.value = value
				end
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: UInt32Value): any
		return wktJson.UInt32Value.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): UInt32Value
		return wktJson.UInt32Value.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

BoolValue = {
	new = function()
		return {
			value = false,
		}
	end,

	encode = function(self: BoolValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, if self.value then 1 else 0)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): BoolValue
		local self = BoolValue.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.value = value ~= 0
				end
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: BoolValue): any
		return wktJson.BoolValue.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): BoolValue
		return wktJson.BoolValue.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

StringValue = {
	new = function()
		return {
			value = "",
		}
	end,

	encode = function(self: StringValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): StringValue
		local self = StringValue.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = buffer.tostring(value)
				end
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: StringValue): any
		return wktJson.StringValue.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): StringValue
		return wktJson.StringValue.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

BytesValue = {
	new = function()
		return {
			value = buffer.create(0),
		}
	end,

	encode = function(self: BytesValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if buffer.len(self.value) > 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, self.value, buffer.len(self.value))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): BytesValue
		local self = BytesValue.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = value
				end
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: BytesValue): any
		return wktJson.BytesValue.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): BytesValue
		return wktJson.BytesValue.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

return {
	DoubleValue = DoubleValue,
	FloatValue = FloatValue,
	Int64Value = Int64Value,
	UInt64Value = UInt64Value,
	Int32Value = Int32Value,
	UInt32Value = UInt32Value,
	BoolValue = BoolValue,
	StringValue = StringValue,
	BytesValue = BytesValue,
}
