--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")
local typeRegistry = require("../../proto/typeRegistry")

local messages: {
	DoubleValue: _DoubleValueMessage,
	FloatValue: _FloatValueMessage,
	Int64Value: _Int64ValueMessage,
	UInt64Value: _UInt64ValueMessage,
	Int32Value: _Int32ValueMessage,
	UInt32Value: _UInt32ValueMessage,
	BoolValue: _BoolValueMessage,
	StringValue: _StringValueMessage,
	BytesValue: _BytesValueMessage,
} =
	{} :: any -- Luau: We will fill these in later

type _DoubleValueImpl = {
	__index: _DoubleValueImpl,
	new: (fields: _DoubleValuePartialFields?) -> DoubleValue,
	encode: (self: DoubleValue) -> buffer,
	decode: (input: buffer) -> DoubleValue,
	jsonEncode: (self: DoubleValue) -> number,
	jsonDecode: (input: number) -> DoubleValue,
	descriptor: proto.Descriptor,
}

type _DoubleValueFields = {
	value: number,
}

type _DoubleValuePartialFields = {
	value: number?,
}

export type DoubleValue = typeof(setmetatable({} :: _DoubleValueFields, {} :: _DoubleValueImpl))

type _FloatValueImpl = {
	__index: _FloatValueImpl,
	new: (fields: _FloatValuePartialFields?) -> FloatValue,
	encode: (self: FloatValue) -> buffer,
	decode: (input: buffer) -> FloatValue,
	jsonEncode: (self: FloatValue) -> number,
	jsonDecode: (input: number) -> FloatValue,
	descriptor: proto.Descriptor,
}

type _FloatValueFields = {
	value: number,
}

type _FloatValuePartialFields = {
	value: number?,
}

export type FloatValue = typeof(setmetatable({} :: _FloatValueFields, {} :: _FloatValueImpl))

type _Int64ValueImpl = {
	__index: _Int64ValueImpl,
	new: (fields: _Int64ValuePartialFields?) -> Int64Value,
	encode: (self: Int64Value) -> buffer,
	decode: (input: buffer) -> Int64Value,
	jsonEncode: (self: Int64Value) -> number,
	jsonDecode: (input: number) -> Int64Value,
	descriptor: proto.Descriptor,
}

type _Int64ValueFields = {
	value: number,
}

type _Int64ValuePartialFields = {
	value: number?,
}

export type Int64Value = typeof(setmetatable({} :: _Int64ValueFields, {} :: _Int64ValueImpl))

type _UInt64ValueImpl = {
	__index: _UInt64ValueImpl,
	new: (fields: _UInt64ValuePartialFields?) -> UInt64Value,
	encode: (self: UInt64Value) -> buffer,
	decode: (input: buffer) -> UInt64Value,
	jsonEncode: (self: UInt64Value) -> number,
	jsonDecode: (input: number) -> UInt64Value,
	descriptor: proto.Descriptor,
}

type _UInt64ValueFields = {
	value: number,
}

type _UInt64ValuePartialFields = {
	value: number?,
}

export type UInt64Value = typeof(setmetatable({} :: _UInt64ValueFields, {} :: _UInt64ValueImpl))

type _Int32ValueImpl = {
	__index: _Int32ValueImpl,
	new: (fields: _Int32ValuePartialFields?) -> Int32Value,
	encode: (self: Int32Value) -> buffer,
	decode: (input: buffer) -> Int32Value,
	jsonEncode: (self: Int32Value) -> number,
	jsonDecode: (input: number) -> Int32Value,
	descriptor: proto.Descriptor,
}

type _Int32ValueFields = {
	value: number,
}

type _Int32ValuePartialFields = {
	value: number?,
}

export type Int32Value = typeof(setmetatable({} :: _Int32ValueFields, {} :: _Int32ValueImpl))

type _UInt32ValueImpl = {
	__index: _UInt32ValueImpl,
	new: (fields: _UInt32ValuePartialFields?) -> UInt32Value,
	encode: (self: UInt32Value) -> buffer,
	decode: (input: buffer) -> UInt32Value,
	jsonEncode: (self: UInt32Value) -> number,
	jsonDecode: (input: number) -> UInt32Value,
	descriptor: proto.Descriptor,
}

type _UInt32ValueFields = {
	value: number,
}

type _UInt32ValuePartialFields = {
	value: number?,
}

export type UInt32Value = typeof(setmetatable({} :: _UInt32ValueFields, {} :: _UInt32ValueImpl))

type _BoolValueImpl = {
	__index: _BoolValueImpl,
	new: (fields: _BoolValuePartialFields?) -> BoolValue,
	encode: (self: BoolValue) -> buffer,
	decode: (input: buffer) -> BoolValue,
	jsonEncode: (self: BoolValue) -> boolean,
	jsonDecode: (input: boolean) -> BoolValue,
	descriptor: proto.Descriptor,
}

type _BoolValueFields = {
	value: boolean,
}

type _BoolValuePartialFields = {
	value: boolean?,
}

export type BoolValue = typeof(setmetatable({} :: _BoolValueFields, {} :: _BoolValueImpl))

type _StringValueImpl = {
	__index: _StringValueImpl,
	new: (fields: _StringValuePartialFields?) -> StringValue,
	encode: (self: StringValue) -> buffer,
	decode: (input: buffer) -> StringValue,
	jsonEncode: (self: StringValue) -> string,
	jsonDecode: (input: string) -> StringValue,
	descriptor: proto.Descriptor,
}

type _StringValueFields = {
	value: string,
}

type _StringValuePartialFields = {
	value: string?,
}

export type StringValue = typeof(setmetatable({} :: _StringValueFields, {} :: _StringValueImpl))

type _BytesValueImpl = {
	__index: _BytesValueImpl,
	new: (fields: _BytesValuePartialFields?) -> BytesValue,
	encode: (self: BytesValue) -> buffer,
	decode: (input: buffer) -> BytesValue,
	jsonEncode: (self: BytesValue) -> string,
	jsonDecode: (input: string) -> BytesValue,
	descriptor: proto.Descriptor,
}

type _BytesValueFields = {
	value: buffer,
}

type _BytesValuePartialFields = {
	value: buffer?,
}

export type BytesValue = typeof(setmetatable({} :: _BytesValueFields, {} :: _BytesValueImpl))

type _DoubleValueMessage = proto.Message<DoubleValue, _DoubleValuePartialFields> & proto.CustomJson<DoubleValue, number>

do
	local _DoubleValueImpl = {}
	_DoubleValueImpl.__index = _DoubleValueImpl

	function _DoubleValueImpl.new(data: _DoubleValuePartialFields?): DoubleValue
		return setmetatable({
			value = if data == nil or data.value == nil then 0 else data.value,

			decode = _DoubleValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _DoubleValueImpl)
	end

	function _DoubleValueImpl.encode(self: DoubleValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= nil and self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i64)
			output, cursor = proto.writeDouble(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _DoubleValueImpl.decode(input: buffer): DoubleValue
		local self = _DoubleValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				if field == 1 then
					local value
					value, cursor = proto.readDouble(input, cursor)
					self.value = value
					continue
				end

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _DoubleValueImpl.jsonEncode(self: DoubleValue): number
		return self.value
	end

	function _DoubleValueImpl.jsonDecode(anyValue: any): DoubleValue
		local value: number = anyValue
		return _DoubleValueImpl.new({
			value = value,
		})
	end

	_DoubleValueImpl.descriptor = {
		name = "DoubleValue",
		fullName = "google.protobuf.DoubleValue",
	}

	messages.DoubleValue = _DoubleValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.DoubleValue)
end

type _FloatValueMessage = proto.Message<FloatValue, _FloatValuePartialFields> & proto.CustomJson<FloatValue, number>

do
	local _FloatValueImpl = {}
	_FloatValueImpl.__index = _FloatValueImpl

	function _FloatValueImpl.new(data: _FloatValuePartialFields?): FloatValue
		return setmetatable({
			value = if data == nil or data.value == nil then 0 else data.value,

			decode = _FloatValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _FloatValueImpl)
	end

	function _FloatValueImpl.encode(self: FloatValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= nil and self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i32)
			output, cursor = proto.writeFloat(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FloatValueImpl.decode(input: buffer): FloatValue
		local self = _FloatValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				if field == 1 then
					local value
					value, cursor = proto.readFloat(input, cursor)
					self.value = value
					continue
				end

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FloatValueImpl.jsonEncode(self: FloatValue): number
		return self.value
	end

	function _FloatValueImpl.jsonDecode(anyValue: any): FloatValue
		local value: number = anyValue
		return _FloatValueImpl.new({
			value = value,
		})
	end

	_FloatValueImpl.descriptor = {
		name = "FloatValue",
		fullName = "google.protobuf.FloatValue",
	}

	messages.FloatValue = _FloatValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FloatValue)
end

type _Int64ValueMessage = proto.Message<Int64Value, _Int64ValuePartialFields> & proto.CustomJson<Int64Value, number>

do
	local _Int64ValueImpl = {}
	_Int64ValueImpl.__index = _Int64ValueImpl

	function _Int64ValueImpl.new(data: _Int64ValuePartialFields?): Int64Value
		return setmetatable({
			value = if data == nil or data.value == nil then 0 else data.value,

			decode = _Int64ValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _Int64ValueImpl)
	end

	function _Int64ValueImpl.encode(self: Int64Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= nil and self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Int64ValueImpl.decode(input: buffer): Int64Value
		local self = _Int64ValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.value = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Int64ValueImpl.jsonEncode(self: Int64Value): number
		return self.value
	end

	function _Int64ValueImpl.jsonDecode(anyValue: any): Int64Value
		local value: number = anyValue
		return _Int64ValueImpl.new({
			value = value,
		})
	end

	_Int64ValueImpl.descriptor = {
		name = "Int64Value",
		fullName = "google.protobuf.Int64Value",
	}

	messages.Int64Value = _Int64ValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Int64Value)
end

type _UInt64ValueMessage = proto.Message<UInt64Value, _UInt64ValuePartialFields> & proto.CustomJson<UInt64Value, number>

do
	local _UInt64ValueImpl = {}
	_UInt64ValueImpl.__index = _UInt64ValueImpl

	function _UInt64ValueImpl.new(data: _UInt64ValuePartialFields?): UInt64Value
		return setmetatable({
			value = if data == nil or data.value == nil then 0 else data.value,

			decode = _UInt64ValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _UInt64ValueImpl)
	end

	function _UInt64ValueImpl.encode(self: UInt64Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= nil and self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UInt64ValueImpl.decode(input: buffer): UInt64Value
		local self = _UInt64ValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntU64(input, cursor)
					self.value = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UInt64ValueImpl.jsonEncode(self: UInt64Value): number
		return self.value
	end

	function _UInt64ValueImpl.jsonDecode(anyValue: any): UInt64Value
		local value: number = anyValue
		return _UInt64ValueImpl.new({
			value = value,
		})
	end

	_UInt64ValueImpl.descriptor = {
		name = "UInt64Value",
		fullName = "google.protobuf.UInt64Value",
	}

	messages.UInt64Value = _UInt64ValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UInt64Value)
end

type _Int32ValueMessage = proto.Message<Int32Value, _Int32ValuePartialFields> & proto.CustomJson<Int32Value, number>

do
	local _Int32ValueImpl = {}
	_Int32ValueImpl.__index = _Int32ValueImpl

	function _Int32ValueImpl.new(data: _Int32ValuePartialFields?): Int32Value
		return setmetatable({
			value = if data == nil or data.value == nil then 0 else data.value,

			decode = _Int32ValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _Int32ValueImpl)
	end

	function _Int32ValueImpl.encode(self: Int32Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= nil and self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Int32ValueImpl.decode(input: buffer): Int32Value
		local self = _Int32ValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.value = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Int32ValueImpl.jsonEncode(self: Int32Value): number
		return self.value
	end

	function _Int32ValueImpl.jsonDecode(anyValue: any): Int32Value
		local value: number = anyValue
		return _Int32ValueImpl.new({
			value = value,
		})
	end

	_Int32ValueImpl.descriptor = {
		name = "Int32Value",
		fullName = "google.protobuf.Int32Value",
	}

	messages.Int32Value = _Int32ValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Int32Value)
end

type _UInt32ValueMessage = proto.Message<UInt32Value, _UInt32ValuePartialFields> & proto.CustomJson<UInt32Value, number>

do
	local _UInt32ValueImpl = {}
	_UInt32ValueImpl.__index = _UInt32ValueImpl

	function _UInt32ValueImpl.new(data: _UInt32ValuePartialFields?): UInt32Value
		return setmetatable({
			value = if data == nil or data.value == nil then 0 else data.value,

			decode = _UInt32ValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _UInt32ValueImpl)
	end

	function _UInt32ValueImpl.encode(self: UInt32Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= nil and self.value ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UInt32ValueImpl.decode(input: buffer): UInt32Value
		local self = _UInt32ValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntU32(input, cursor)
					self.value = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UInt32ValueImpl.jsonEncode(self: UInt32Value): number
		return self.value
	end

	function _UInt32ValueImpl.jsonDecode(anyValue: any): UInt32Value
		local value: number = anyValue
		return _UInt32ValueImpl.new({
			value = value,
		})
	end

	_UInt32ValueImpl.descriptor = {
		name = "UInt32Value",
		fullName = "google.protobuf.UInt32Value",
	}

	messages.UInt32Value = _UInt32ValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UInt32Value)
end

type _BoolValueMessage = proto.Message<BoolValue, _BoolValuePartialFields> & proto.CustomJson<BoolValue, boolean>

do
	local _BoolValueImpl = {}
	_BoolValueImpl.__index = _BoolValueImpl

	function _BoolValueImpl.new(data: _BoolValuePartialFields?): BoolValue
		return setmetatable({
			value = if data == nil or data.value == nil then false else data.value,

			decode = _BoolValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _BoolValueImpl)
	end

	function _BoolValueImpl.encode(self: BoolValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, if self.value then 1 else 0)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BoolValueImpl.decode(input: buffer): BoolValue
		local self = _BoolValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.value = value ~= 0
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BoolValueImpl.jsonEncode(self: BoolValue): boolean
		return self.value
	end

	function _BoolValueImpl.jsonDecode(anyValue: any): BoolValue
		local value: boolean = anyValue
		return _BoolValueImpl.new({
			value = value,
		})
	end

	_BoolValueImpl.descriptor = {
		name = "BoolValue",
		fullName = "google.protobuf.BoolValue",
	}

	messages.BoolValue = _BoolValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BoolValue)
end

type _StringValueMessage = proto.Message<StringValue, _StringValuePartialFields> & proto.CustomJson<StringValue, string>

do
	local _StringValueImpl = {}
	_StringValueImpl.__index = _StringValueImpl

	function _StringValueImpl.new(data: _StringValuePartialFields?): StringValue
		return setmetatable({
			value = if data == nil or data.value == nil then "" else data.value,

			decode = _StringValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _StringValueImpl)
	end

	function _StringValueImpl.encode(self: StringValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= nil and self.value ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StringValueImpl.decode(input: buffer): StringValue
		local self = _StringValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StringValueImpl.jsonEncode(self: StringValue): string
		return self.value
	end

	function _StringValueImpl.jsonDecode(anyValue: any): StringValue
		local value: string = anyValue
		return _StringValueImpl.new({
			value = value,
		})
	end

	_StringValueImpl.descriptor = {
		name = "StringValue",
		fullName = "google.protobuf.StringValue",
	}

	messages.StringValue = _StringValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StringValue)
end

type _BytesValueMessage = proto.Message<BytesValue, _BytesValuePartialFields> & proto.CustomJson<BytesValue, string>

do
	local _BytesValueImpl = {}
	_BytesValueImpl.__index = _BytesValueImpl

	function _BytesValueImpl.new(data: _BytesValuePartialFields?): BytesValue
		return setmetatable({
			value = if data == nil or data.value == nil then buffer.create(0) else data.value,

			decode = _BytesValueImpl.decode, -- Luau: Fixes rare bug with "missing fields decode"
		}, _BytesValueImpl)
	end

	function _BytesValueImpl.encode(self: BytesValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.value ~= nil and buffer.len(self.value) > 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, self.value, buffer.len(self.value))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BytesValueImpl.decode(input: buffer): BytesValue
		local self = _BytesValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = value
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BytesValueImpl.jsonEncode(self: BytesValue): string
		return buffer.tostring(self.value)
	end

	function _BytesValueImpl.jsonDecode(anyValue: any): BytesValue
		local value: string = anyValue
		return _BytesValueImpl.new({
			value = buffer.fromstring(value),
		})
	end

	_BytesValueImpl.descriptor = {
		name = "BytesValue",
		fullName = "google.protobuf.BytesValue",
	}

	messages.BytesValue = _BytesValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BytesValue)
end

return {
	DoubleValue = messages.DoubleValue,
	FloatValue = messages.FloatValue,
	Int64Value = messages.Int64Value,
	UInt64Value = messages.UInt64Value,
	Int32Value = messages.Int32Value,
	UInt32Value = messages.UInt32Value,
	BoolValue = messages.BoolValue,
	StringValue = messages.StringValue,
	BytesValue = messages.BytesValue,
}
