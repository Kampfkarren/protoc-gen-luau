--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")
local wktJson = require("../../proto/wktJson")

type _DoubleValueImpl = {
	__index: _DoubleValueImpl,
	new: () -> DoubleValue,
	encode: (self: DoubleValue) -> string,
	decode: (input: buffer) -> DoubleValue,
	jsonEncode: (self: DoubleValue) -> any,
	jsonDecode: (input: { [string]: any }) -> DoubleValue,
}

type _DoubleValueFields = {
	value: number,
}

export type DoubleValue = typeof(setmetatable({} :: _DoubleValueFields, {} :: _DoubleValueImpl))
type _FloatValueImpl = {
	__index: _FloatValueImpl,
	new: () -> FloatValue,
	encode: (self: FloatValue) -> string,
	decode: (input: buffer) -> FloatValue,
	jsonEncode: (self: FloatValue) -> any,
	jsonDecode: (input: { [string]: any }) -> FloatValue,
}

type _FloatValueFields = {
	value: number,
}

export type FloatValue = typeof(setmetatable({} :: _FloatValueFields, {} :: _FloatValueImpl))
type _Int64ValueImpl = {
	__index: _Int64ValueImpl,
	new: () -> Int64Value,
	encode: (self: Int64Value) -> string,
	decode: (input: buffer) -> Int64Value,
	jsonEncode: (self: Int64Value) -> any,
	jsonDecode: (input: { [string]: any }) -> Int64Value,
}

type _Int64ValueFields = {
	value: number,
}

export type Int64Value = typeof(setmetatable({} :: _Int64ValueFields, {} :: _Int64ValueImpl))
type _UInt64ValueImpl = {
	__index: _UInt64ValueImpl,
	new: () -> UInt64Value,
	encode: (self: UInt64Value) -> string,
	decode: (input: buffer) -> UInt64Value,
	jsonEncode: (self: UInt64Value) -> any,
	jsonDecode: (input: { [string]: any }) -> UInt64Value,
}

type _UInt64ValueFields = {
	value: number,
}

export type UInt64Value = typeof(setmetatable({} :: _UInt64ValueFields, {} :: _UInt64ValueImpl))
type _Int32ValueImpl = {
	__index: _Int32ValueImpl,
	new: () -> Int32Value,
	encode: (self: Int32Value) -> string,
	decode: (input: buffer) -> Int32Value,
	jsonEncode: (self: Int32Value) -> any,
	jsonDecode: (input: { [string]: any }) -> Int32Value,
}

type _Int32ValueFields = {
	value: number,
}

export type Int32Value = typeof(setmetatable({} :: _Int32ValueFields, {} :: _Int32ValueImpl))
type _UInt32ValueImpl = {
	__index: _UInt32ValueImpl,
	new: () -> UInt32Value,
	encode: (self: UInt32Value) -> string,
	decode: (input: buffer) -> UInt32Value,
	jsonEncode: (self: UInt32Value) -> any,
	jsonDecode: (input: { [string]: any }) -> UInt32Value,
}

type _UInt32ValueFields = {
	value: number,
}

export type UInt32Value = typeof(setmetatable({} :: _UInt32ValueFields, {} :: _UInt32ValueImpl))
type _BoolValueImpl = {
	__index: _BoolValueImpl,
	new: () -> BoolValue,
	encode: (self: BoolValue) -> string,
	decode: (input: buffer) -> BoolValue,
	jsonEncode: (self: BoolValue) -> any,
	jsonDecode: (input: { [string]: any }) -> BoolValue,
}

type _BoolValueFields = {
	value: boolean,
}

export type BoolValue = typeof(setmetatable({} :: _BoolValueFields, {} :: _BoolValueImpl))
type _StringValueImpl = {
	__index: _StringValueImpl,
	new: () -> StringValue,
	encode: (self: StringValue) -> string,
	decode: (input: buffer) -> StringValue,
	jsonEncode: (self: StringValue) -> any,
	jsonDecode: (input: { [string]: any }) -> StringValue,
}

type _StringValueFields = {
	value: string,
}

export type StringValue = typeof(setmetatable({} :: _StringValueFields, {} :: _StringValueImpl))
type _BytesValueImpl = {
	__index: _BytesValueImpl,
	new: () -> BytesValue,
	encode: (self: BytesValue) -> string,
	decode: (input: buffer) -> BytesValue,
	jsonEncode: (self: BytesValue) -> any,
	jsonDecode: (input: { [string]: any }) -> BytesValue,
}

type _BytesValueFields = {
	value: buffer,
}

export type BytesValue = typeof(setmetatable({} :: _BytesValueFields, {} :: _BytesValueImpl))

local DoubleValue: proto.Message<_DoubleValueImpl> = {} :: _DoubleValueImpl
DoubleValue.__index = DoubleValue

function DoubleValue.new(data: _DoubleValueFields?): DoubleValue
	return setmetatable({
		value = data and data["value"] or 0,
	}, DoubleValue)
end

function DoubleValue.encode(self: DoubleValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i64)
		output, cursor = proto.writeDouble(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function DoubleValue.decode(input: buffer): DoubleValue
	local self = DoubleValue.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			if field == 1 then
				local value
				value, cursor = proto.readDouble(input, cursor)
				self.value = value
			end
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function DoubleValue.jsonEncode(self: DoubleValue): any
	return wktJson.DoubleValue.serialize(self :: any)
end

function DoubleValue.jsonDecode(input: { [string]: any }): DoubleValue
	return wktJson.DoubleValue.deserialize(input :: any, DoubleValue.new) -- any cast because we have a special jsonDecode
end

local FloatValue: proto.Message<_FloatValueImpl> = {} :: _FloatValueImpl
FloatValue.__index = FloatValue

function FloatValue.new(data: _FloatValueFields?): FloatValue
	return setmetatable({
		value = data and data["value"] or 0,
	}, FloatValue)
end

function FloatValue.encode(self: FloatValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i32)
		output, cursor = proto.writeFloat(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function FloatValue.decode(input: buffer): FloatValue
	local self = FloatValue.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			if field == 1 then
				local value
				value, cursor = proto.readFloat(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function FloatValue.jsonEncode(self: FloatValue): any
	return wktJson.FloatValue.serialize(self :: any)
end

function FloatValue.jsonDecode(input: { [string]: any }): FloatValue
	return wktJson.FloatValue.deserialize(input :: any, FloatValue.new) -- any cast because we have a special jsonDecode
end

local Int64Value: proto.Message<_Int64ValueImpl> = {} :: _Int64ValueImpl
Int64Value.__index = Int64Value

function Int64Value.new(data: _Int64ValueFields?): Int64Value
	return setmetatable({
		value = data and data["value"] or 0,
	}, Int64Value)
end

function Int64Value.encode(self: Int64Value): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Int64Value.decode(input: buffer): Int64Value
	local self = Int64Value.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Int64Value.jsonEncode(self: Int64Value): any
	return wktJson.Int64Value.serialize(self :: any)
end

function Int64Value.jsonDecode(input: { [string]: any }): Int64Value
	return wktJson.Int64Value.deserialize(input :: any, Int64Value.new) -- any cast because we have a special jsonDecode
end

local UInt64Value: proto.Message<_UInt64ValueImpl> = {} :: _UInt64ValueImpl
UInt64Value.__index = UInt64Value

function UInt64Value.new(data: _UInt64ValueFields?): UInt64Value
	return setmetatable({
		value = data and data["value"] or 0,
	}, UInt64Value)
end

function UInt64Value.encode(self: UInt64Value): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function UInt64Value.decode(input: buffer): UInt64Value
	local self = UInt64Value.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function UInt64Value.jsonEncode(self: UInt64Value): any
	return wktJson.UInt64Value.serialize(self :: any)
end

function UInt64Value.jsonDecode(input: { [string]: any }): UInt64Value
	return wktJson.UInt64Value.deserialize(input :: any, UInt64Value.new) -- any cast because we have a special jsonDecode
end

local Int32Value: proto.Message<_Int32ValueImpl> = {} :: _Int32ValueImpl
Int32Value.__index = Int32Value

function Int32Value.new(data: _Int32ValueFields?): Int32Value
	return setmetatable({
		value = data and data["value"] or 0,
	}, Int32Value)
end

function Int32Value.encode(self: Int32Value): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Int32Value.decode(input: buffer): Int32Value
	local self = Int32Value.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = proto.limitInt32(value)
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Int32Value.jsonEncode(self: Int32Value): any
	return wktJson.Int32Value.serialize(self :: any)
end

function Int32Value.jsonDecode(input: { [string]: any }): Int32Value
	return wktJson.Int32Value.deserialize(input :: any, Int32Value.new) -- any cast because we have a special jsonDecode
end

local UInt32Value: proto.Message<_UInt32ValueImpl> = {} :: _UInt32ValueImpl
UInt32Value.__index = UInt32Value

function UInt32Value.new(data: _UInt32ValueFields?): UInt32Value
	return setmetatable({
		value = data and data["value"] or 0,
	}, UInt32Value)
end

function UInt32Value.encode(self: UInt32Value): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function UInt32Value.decode(input: buffer): UInt32Value
	local self = UInt32Value.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function UInt32Value.jsonEncode(self: UInt32Value): any
	return wktJson.UInt32Value.serialize(self :: any)
end

function UInt32Value.jsonDecode(input: { [string]: any }): UInt32Value
	return wktJson.UInt32Value.deserialize(input :: any, UInt32Value.new) -- any cast because we have a special jsonDecode
end

local BoolValue: proto.Message<_BoolValueImpl> = {} :: _BoolValueImpl
BoolValue.__index = BoolValue

function BoolValue.new(data: _BoolValueFields?): BoolValue
	return setmetatable({
		value = data and data["value"] or false,
	}, BoolValue)
end

function BoolValue.encode(self: BoolValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, if self.value then 1 else 0)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function BoolValue.decode(input: buffer): BoolValue
	local self = BoolValue.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = value ~= 0
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function BoolValue.jsonEncode(self: BoolValue): any
	return wktJson.BoolValue.serialize(self :: any)
end

function BoolValue.jsonDecode(input: { [string]: any }): BoolValue
	return wktJson.BoolValue.deserialize(input :: any, BoolValue.new) -- any cast because we have a special jsonDecode
end

local StringValue: proto.Message<_StringValueImpl> = {} :: _StringValueImpl
StringValue.__index = StringValue

function StringValue.new(data: _StringValueFields?): StringValue
	return setmetatable({
		value = data and data["value"] or "",
	}, StringValue)
end

function StringValue.encode(self: StringValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function StringValue.decode(input: buffer): StringValue
	local self = StringValue.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.value = buffer.tostring(value)
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function StringValue.jsonEncode(self: StringValue): any
	return wktJson.StringValue.serialize(self :: any)
end

function StringValue.jsonDecode(input: { [string]: any }): StringValue
	return wktJson.StringValue.deserialize(input :: any, StringValue.new) -- any cast because we have a special jsonDecode
end

local BytesValue: proto.Message<_BytesValueImpl> = {} :: _BytesValueImpl
BytesValue.__index = BytesValue

function BytesValue.new(data: _BytesValueFields?): BytesValue
	return setmetatable({
		value = data and data["value"] or buffer.create(0),
	}, BytesValue)
end

function BytesValue.encode(self: BytesValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if buffer.len(self.value) > 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeBuffer(output, cursor, self.value, buffer.len(self.value))
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function BytesValue.decode(input: buffer): BytesValue
	local self = BytesValue.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function BytesValue.jsonEncode(self: BytesValue): any
	return wktJson.BytesValue.serialize(self :: any)
end

function BytesValue.jsonDecode(input: { [string]: any }): BytesValue
	return wktJson.BytesValue.deserialize(input :: any, BytesValue.new) -- any cast because we have a special jsonDecode
end

return {
	DoubleValue = DoubleValue,
	FloatValue = FloatValue,
	Int64Value = Int64Value,
	UInt64Value = UInt64Value,
	Int32Value = Int32Value,
	UInt32Value = UInt32Value,
	BoolValue = BoolValue,
	StringValue = StringValue,
	BytesValue = BytesValue,
}
