--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")

type _DoubleValueImpl = {
	__index: _DoubleValueImpl,
	new: () -> DoubleValue,
	encode: (self: DoubleValue) -> buffer,
	decode: (input: buffer) -> DoubleValue,
	jsonEncode: (self: DoubleValue) -> number,
	jsonDecode: (input: number) -> DoubleValue,
	descriptor: proto.Descriptor,
}

type _DoubleValueFields = {
	value: number,
}

export type DoubleValue = typeof(setmetatable({} :: _DoubleValueFields, {} :: _DoubleValueImpl))
local DoubleValue: proto.Message<DoubleValue>

type _FloatValueImpl = {
	__index: _FloatValueImpl,
	new: () -> FloatValue,
	encode: (self: FloatValue) -> buffer,
	decode: (input: buffer) -> FloatValue,
	jsonEncode: (self: FloatValue) -> number,
	jsonDecode: (input: number) -> FloatValue,
	descriptor: proto.Descriptor,
}

type _FloatValueFields = {
	value: number,
}

export type FloatValue = typeof(setmetatable({} :: _FloatValueFields, {} :: _FloatValueImpl))
local FloatValue: proto.Message<FloatValue>

type _Int64ValueImpl = {
	__index: _Int64ValueImpl,
	new: () -> Int64Value,
	encode: (self: Int64Value) -> buffer,
	decode: (input: buffer) -> Int64Value,
	jsonEncode: (self: Int64Value) -> number,
	jsonDecode: (input: number) -> Int64Value,
	descriptor: proto.Descriptor,
}

type _Int64ValueFields = {
	value: number,
}

export type Int64Value = typeof(setmetatable({} :: _Int64ValueFields, {} :: _Int64ValueImpl))
local Int64Value: proto.Message<Int64Value>

type _UInt64ValueImpl = {
	__index: _UInt64ValueImpl,
	new: () -> UInt64Value,
	encode: (self: UInt64Value) -> buffer,
	decode: (input: buffer) -> UInt64Value,
	jsonEncode: (self: UInt64Value) -> number,
	jsonDecode: (input: number) -> UInt64Value,
	descriptor: proto.Descriptor,
}

type _UInt64ValueFields = {
	value: number,
}

export type UInt64Value = typeof(setmetatable({} :: _UInt64ValueFields, {} :: _UInt64ValueImpl))
local UInt64Value: proto.Message<UInt64Value>

type _Int32ValueImpl = {
	__index: _Int32ValueImpl,
	new: () -> Int32Value,
	encode: (self: Int32Value) -> buffer,
	decode: (input: buffer) -> Int32Value,
	jsonEncode: (self: Int32Value) -> number,
	jsonDecode: (input: number) -> Int32Value,
	descriptor: proto.Descriptor,
}

type _Int32ValueFields = {
	value: number,
}

export type Int32Value = typeof(setmetatable({} :: _Int32ValueFields, {} :: _Int32ValueImpl))
local Int32Value: proto.Message<Int32Value>

type _UInt32ValueImpl = {
	__index: _UInt32ValueImpl,
	new: () -> UInt32Value,
	encode: (self: UInt32Value) -> buffer,
	decode: (input: buffer) -> UInt32Value,
	jsonEncode: (self: UInt32Value) -> number,
	jsonDecode: (input: number) -> UInt32Value,
	descriptor: proto.Descriptor,
}

type _UInt32ValueFields = {
	value: number,
}

export type UInt32Value = typeof(setmetatable({} :: _UInt32ValueFields, {} :: _UInt32ValueImpl))
local UInt32Value: proto.Message<UInt32Value>

type _BoolValueImpl = {
	__index: _BoolValueImpl,
	new: () -> BoolValue,
	encode: (self: BoolValue) -> buffer,
	decode: (input: buffer) -> BoolValue,
	jsonEncode: (self: BoolValue) -> boolean,
	jsonDecode: (input: boolean) -> BoolValue,
	descriptor: proto.Descriptor,
}

type _BoolValueFields = {
	value: boolean,
}

export type BoolValue = typeof(setmetatable({} :: _BoolValueFields, {} :: _BoolValueImpl))
local BoolValue: proto.Message<BoolValue>

type _StringValueImpl = {
	__index: _StringValueImpl,
	new: () -> StringValue,
	encode: (self: StringValue) -> buffer,
	decode: (input: buffer) -> StringValue,
	jsonEncode: (self: StringValue) -> string,
	jsonDecode: (input: string) -> StringValue,
	descriptor: proto.Descriptor,
}

type _StringValueFields = {
	value: string,
}

export type StringValue = typeof(setmetatable({} :: _StringValueFields, {} :: _StringValueImpl))
local StringValue: proto.Message<StringValue>

type _BytesValueImpl = {
	__index: _BytesValueImpl,
	new: () -> BytesValue,
	encode: (self: BytesValue) -> buffer,
	decode: (input: buffer) -> BytesValue,
	jsonEncode: (self: BytesValue) -> buffer,
	jsonDecode: (input: buffer) -> BytesValue,
	descriptor: proto.Descriptor,
}

type _BytesValueFields = {
	value: buffer,
}

export type BytesValue = typeof(setmetatable({} :: _BytesValueFields, {} :: _BytesValueImpl))
local BytesValue: proto.Message<BytesValue>

local _DoubleValueImpl = {}
_DoubleValueImpl.__index = _DoubleValueImpl

function _DoubleValueImpl.new(data: _DoubleValueFields?): DoubleValue
	return setmetatable({
		value = if data == nil then 0 else data.value,
	}, _DoubleValueImpl)
end

function _DoubleValueImpl.encode(self: DoubleValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= nil and self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i64)
		output, cursor = proto.writeDouble(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _DoubleValueImpl.decode(input: buffer): DoubleValue
	local self = _DoubleValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			if field == 1 then
				local value
				value, cursor = proto.readDouble(input, cursor)
				self.value = value
			end
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_DoubleValueImpl.descriptor = {
	name = "DoubleValue",
	fullName = "google.protobuf.DoubleValue",
}

DoubleValue = _DoubleValueImpl

local _FloatValueImpl = {}
_FloatValueImpl.__index = _FloatValueImpl

function _FloatValueImpl.new(data: _FloatValueFields?): FloatValue
	return setmetatable({
		value = if data == nil then 0 else data.value,
	}, _FloatValueImpl)
end

function _FloatValueImpl.encode(self: FloatValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= nil and self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i32)
		output, cursor = proto.writeFloat(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _FloatValueImpl.decode(input: buffer): FloatValue
	local self = _FloatValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			if field == 1 then
				local value
				value, cursor = proto.readFloat(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_FloatValueImpl.descriptor = {
	name = "FloatValue",
	fullName = "google.protobuf.FloatValue",
}

FloatValue = _FloatValueImpl

local _Int64ValueImpl = {}
_Int64ValueImpl.__index = _Int64ValueImpl

function _Int64ValueImpl.new(data: _Int64ValueFields?): Int64Value
	return setmetatable({
		value = if data == nil then 0 else data.value,
	}, _Int64ValueImpl)
end

function _Int64ValueImpl.encode(self: Int64Value): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= nil and self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _Int64ValueImpl.decode(input: buffer): Int64Value
	local self = _Int64ValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_Int64ValueImpl.descriptor = {
	name = "Int64Value",
	fullName = "google.protobuf.Int64Value",
}

Int64Value = _Int64ValueImpl

local _UInt64ValueImpl = {}
_UInt64ValueImpl.__index = _UInt64ValueImpl

function _UInt64ValueImpl.new(data: _UInt64ValueFields?): UInt64Value
	return setmetatable({
		value = if data == nil then 0 else data.value,
	}, _UInt64ValueImpl)
end

function _UInt64ValueImpl.encode(self: UInt64Value): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= nil and self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _UInt64ValueImpl.decode(input: buffer): UInt64Value
	local self = _UInt64ValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_UInt64ValueImpl.descriptor = {
	name = "UInt64Value",
	fullName = "google.protobuf.UInt64Value",
}

UInt64Value = _UInt64ValueImpl

local _Int32ValueImpl = {}
_Int32ValueImpl.__index = _Int32ValueImpl

function _Int32ValueImpl.new(data: _Int32ValueFields?): Int32Value
	return setmetatable({
		value = if data == nil then 0 else data.value,
	}, _Int32ValueImpl)
end

function _Int32ValueImpl.encode(self: Int32Value): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= nil and self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _Int32ValueImpl.decode(input: buffer): Int32Value
	local self = _Int32ValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = proto.limitInt32(value)
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_Int32ValueImpl.descriptor = {
	name = "Int32Value",
	fullName = "google.protobuf.Int32Value",
}

Int32Value = _Int32ValueImpl

local _UInt32ValueImpl = {}
_UInt32ValueImpl.__index = _UInt32ValueImpl

function _UInt32ValueImpl.new(data: _UInt32ValueFields?): UInt32Value
	return setmetatable({
		value = if data == nil then 0 else data.value,
	}, _UInt32ValueImpl)
end

function _UInt32ValueImpl.encode(self: UInt32Value): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value ~= nil and self.value ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _UInt32ValueImpl.decode(input: buffer): UInt32Value
	local self = _UInt32ValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_UInt32ValueImpl.descriptor = {
	name = "UInt32Value",
	fullName = "google.protobuf.UInt32Value",
}

UInt32Value = _UInt32ValueImpl

local _BoolValueImpl = {}
_BoolValueImpl.__index = _BoolValueImpl

function _BoolValueImpl.new(data: _BoolValueFields?): BoolValue
	return setmetatable({
		value = if data == nil then false else data.value,
	}, _BoolValueImpl)
end

function _BoolValueImpl.encode(self: BoolValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, if self.value then 1 else 0)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _BoolValueImpl.decode(input: buffer): BoolValue
	local self = _BoolValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.value = value ~= 0
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_BoolValueImpl.descriptor = {
	name = "BoolValue",
	fullName = "google.protobuf.BoolValue",
}

BoolValue = _BoolValueImpl

local _StringValueImpl = {}
_StringValueImpl.__index = _StringValueImpl

function _StringValueImpl.new(data: _StringValueFields?): StringValue
	return setmetatable({
		value = if data == nil then "" else data.value,
	}, _StringValueImpl)
end

function _StringValueImpl.encode(self: StringValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value and self.value ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _StringValueImpl.decode(input: buffer): StringValue
	local self = _StringValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.value = buffer.tostring(value)
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_StringValueImpl.descriptor = {
	name = "StringValue",
	fullName = "google.protobuf.StringValue",
}

StringValue = _StringValueImpl

local _BytesValueImpl = {}
_BytesValueImpl.__index = _BytesValueImpl

function _BytesValueImpl.new(data: _BytesValueFields?): BytesValue
	return setmetatable({
		value = if data == nil then buffer.create(0) else data.value,
	}, _BytesValueImpl)
end

function _BytesValueImpl.encode(self: BytesValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.value and buffer.len(self.value) > 0 then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeBuffer(output, cursor, self.value, buffer.len(self.value))
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function _BytesValueImpl.decode(input: buffer): BytesValue
	local self = _BytesValueImpl.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

_BytesValueImpl.descriptor = {
	name = "BytesValue",
	fullName = "google.protobuf.BytesValue",
}

BytesValue = _BytesValueImpl

function BoolValue.jsonEncode(value: BoolValue): boolean
	return value.value
end

function BoolValue.jsonDecode(value: boolean): BoolValue
	return BoolValue.new({
		value = value,
	})
end

function BytesValue.jsonEncode(value: BytesValue): buffer
	return value.value
end

function BytesValue.jsonDecode(value: buffer): BytesValue
	return BytesValue.new({
		value = value,
	})
end

function DoubleValue.jsonEncode(value: DoubleValue): number
	return value.value
end

function DoubleValue.jsonDecode(value: number): DoubleValue
	return DoubleValue.new({
		value = value,
	})
end

function FloatValue.jsonEncode(value: FloatValue): number
	return value.value
end

function FloatValue.jsonDecode(value: number): FloatValue
	return FloatValue.new({
		value = value,
	})
end

function Int32Value.jsonEncode(value: Int32Value): number
	return value.value
end

function Int32Value.jsonDecode(value: number): Int32Value
	return Int32Value.new({
		value = value,
	})
end

function Int64Value.jsonEncode(value: Int64Value): number
	return value.value
end

function Int64Value.jsonDecode(value: number): Int64Value
	return Int64Value.new({
		value = value,
	})
end

function UInt32Value.jsonEncode(value: UInt32Value): number
	return value.value
end

function UInt32Value.jsonDecode(value: number): UInt32Value
	return UInt32Value.new({
		value = value,
	})
end

function UInt64Value.jsonEncode(value: UInt64Value): number
	return value.value
end

function UInt64Value.jsonDecode(value: number): UInt64Value
	return UInt64Value.new({
		value = value,
	})
end

function StringValue.jsonEncode(value: StringValue): string
	return value.value
end

function StringValue.jsonDecode(value: string): StringValue
	return StringValue.new({
		value = value,
	})
end
return {
	DoubleValue = DoubleValue,
	FloatValue = FloatValue,
	Int64Value = Int64Value,
	UInt64Value = UInt64Value,
	Int32Value = Int32Value,
	UInt32Value = UInt32Value,
	BoolValue = BoolValue,
	StringValue = StringValue,
	BytesValue = BytesValue,
}
