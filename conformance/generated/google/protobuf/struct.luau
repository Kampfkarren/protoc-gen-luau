--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")
local wktJson = require("../../proto/wktJson")

local Struct: proto.Message<Struct>
export type Struct = {
	fields: { [string]: Value },
}

local Struct_FieldsEntry: proto.Message<Struct_FieldsEntry>
export type Struct_FieldsEntry = {
	key: string,
	value: Value?,
}

local Value: proto.Message<Value>
export type Value = {
	kind: (
		{ type: "null_value", value: NullValue }
		| { type: "number_value", value: number }
		| { type: "string_value", value: string }
		| { type: "bool_value", value: boolean }
		| { type: "struct_value", value: Struct }
		| { type: "list_value", value: ListValue }
	)?,
}

local ListValue: proto.Message<ListValue>
export type ListValue = {
	values: { Value },
}

local NullValue: proto.Enum<NullValue>
export type NullValue = "NULL_VALUE" | number -- Unknown

Struct = {
	new = function()
		return {
			fields = {},
		}
	end,

	encode = function(self: Struct): buffer
		local output = buffer.create(0)
		local cursor = 0

		if next(self.fields) ~= nil then
			for key: string, value: Value in self.fields do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				local encoded = Value.encode(value)
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeBuffer(mapBuffer, mapCursor, encoded, buffer.len(encoded))
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): Struct
		local self = Struct.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = Struct_FieldsEntry.decode(value)

					local keyDefault = ""
					local valueDefault = Value.new()

					self.fields[mapEntry.key or keyDefault] = mapEntry.value or valueDefault
				end
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: Struct): any
		return wktJson.Struct.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): Struct
		return wktJson.Struct.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

Struct_FieldsEntry = {
	new = function()
		return {
			key = "",
			value = nil,
		}
	end,

	encode = function(self: Struct_FieldsEntry): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil then
			local encoded = Value.encode(self.value)
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): Struct_FieldsEntry
		local self = Struct_FieldsEntry.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = Value.decode(value)
				end
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: Struct_FieldsEntry): any
		local output: {
			key: string?,
			value: Value?,
		} = {}

		if self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil then
			output.value = Value.jsonEncode(self.value)
		end

		return output
	end,

	jsonDecode = function(input: { [string]: any }): Struct_FieldsEntry
		local self = Struct_FieldsEntry.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = Value.jsonDecode(input.value)
		end

		return self
	end,
}

Value = {
	new = function()
		return {
			kind = nil,
		}
	end,

	encode = function(self: Value): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "null_value" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, NullValue.toNumber(self.kind.value))
			elseif self.kind.type == "number_value" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.i64)
				output, cursor = proto.writeDouble(output, cursor, self.kind.value)
			elseif self.kind.type == "string_value" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "bool_value" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, if self.kind.value then 1 else 0)
			elseif self.kind.type == "struct_value" then
				local encoded = Struct.encode(self.kind.value)
				output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "list_value" then
				local encoded = ListValue.encode(self.kind.value)
				output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): Value
		local self = Value.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.kind = { type = "null_value", value = NullValue.fromNumber(value) or value }
				elseif field == 4 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.kind = { type = "bool_value", value = value ~= 0 }
				end
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "string_value", value = buffer.tostring(value) }
				elseif field == 5 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "struct_value", value = Struct.decode(value) }
				elseif field == 6 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "list_value", value = ListValue.decode(value) }
				end
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				if field == 2 then
					local value
					value, cursor = proto.readDouble(input, cursor)
					self.kind = { type = "number_value", value = value }
				end
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: Value): any
		return wktJson.Value.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): Value
		return wktJson.Value.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

ListValue = {
	new = function()
		return {
			values = {},
		}
	end,

	encode = function(self: ListValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if #self.values > 0 then
			for _, value: Value in self.values do
				local encoded = Value.encode(value)
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end,

	decode = function(input: buffer): ListValue
		local self = ListValue.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.values, Value.decode(value))
				end
			elseif wireType == proto.wireTypes.i32 then
				-- No fields
			elseif wireType == proto.wireTypes.i64 then
				-- No fields
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end,

	jsonEncode = function(self: ListValue): any
		return wktJson.ListValue.serialize(self :: any)
	end,

	jsonDecode = function(input: { [string]: any }): ListValue
		return wktJson.ListValue.deserialize(input :: any) -- any cast because we have a special jsonDecode
	end,
}

NullValue = {
	fromNumber = function(value: number): NullValue?
		if value == 0 then
			return "NULL_VALUE"
		else
			return nil
		end
	end,

	toNumber = function(self: NullValue): number
		if self == "NULL_VALUE" then
			return 0
		else
			return self
		end
	end,

	fromName = function(name: string): NullValue?
		if name == "NULL_VALUE" then
			return "NULL_VALUE"
		else
			return nil
		end
	end,
}

return {
	Struct = Struct,
	Value = Value,
	ListValue = ListValue,
	NullValue = NullValue,
}
